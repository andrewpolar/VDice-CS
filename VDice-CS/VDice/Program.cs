//This is demo of modeling stochastic systemts by divisive data resorting algorithm,
//developed by Andrew Polar and Mike Poluektov.
//The data is generated by rolling two sets of dice with different quantities.
//There is also random variable, which is the probability switch between either of these sets.
//The data set is generated by DataHolder dh = new DataHolder(10, 2000);
//The first accuracy metric is the relative distance between two nested median trees, the details
//can be found on page http://www.ezcodesample.com/MTree.html
//The second accuracy test is Cramer vom Mises for significance threshold 0.05.
//The deterministic component is Kolmogorov-Arnold representation.
//Code written by Andrew Polar.

//The data generation details.
//3 inputs, all are integers 1 through 10. Like 4, 7, 5.
//7 and 5 are quantities of dice. Either of these two dice sets is randomly chosen and rolled.
//The probability of choosing dice set is determined by the first input 4.  The dice are
//virtual, they have 10 edges, so 4/10 is probability of choosing first set, assuming
//choosing the other as opposite event. The output is a sum of all outputs in a random roll.
//After model is built by method slider.BuildModels, the predicted set of possible outcomes
//can be obtained by calling slider.GetOutput. The model can return sample large enough to
//build input dependent distribution.

//The training data is 2000 individual records from 1000 different populations.  
//The details of Divisive Data Resorting method can be found in video https://www.youtube.com/watch?v=0hhJIpzxPR0

using System;
using System.Collections.Generic;

namespace VDice
{
    internal class Program
    {
        static void Main(string[] args)
        {
            DataHolder dh = new DataHolder(10, 2000);
            dh.MakeDataset();

            DateTime start = DateTime.Now;
            Console.WriteLine("Resorting...");

            //Sliding window model
            Resorter resorter = new Resorter();
            resorter.ReadData(dh);
            resorter.Resort(1);
            resorter.Resort(2);
            resorter.Resort(4);
            resorter.Resort(8);
            resorter.Resort(16);
            resorter.Resort(32);
 
            SlidingKMEnsemple slider = new SlidingKMEnsemple(dh._inputs, dh._target);
            slider.BuildModels(10, 50);

            DateTime end = DateTime.Now;
            TimeSpan duration = end - start;
            double time = duration.Minutes * 60.0 + duration.Seconds + duration.Milliseconds / 1000.0;
            Console.WriteLine("Processing time for DDR {0:####.00} seconds", time);

            //Accuracy test
            int NTests = 100;
            double mean_dist = 0.0;
            int passed_CVMs = 0;
            List<double> meanModel = new List<double>();
            List<double> meanMC = new List<double>();
            List<double> stdModel = new List<double>();
            List<double> stdMC = new List<double>();
            List<double> expectationModel = new List<double>();
            List<double> stdDirectModel = new List<double>();
            for (int i = 0; i < NTests; ++i)
            {
                double[] randomInput = dh.MakeRandomInput();
                double[] monte_carlo = dh.GetMonteCarloSample(randomInput, 4096);
                double[] ddrMT = slider.GetOutput(randomInput, 0.2, 10);
                double[] ddrCVM = slider.GetOutput(randomInput, 0.0, 1);

                double meanDDR = Static.GetMean(ddrCVM);
                double meanMonteCarlo = Static.GetMean(monte_carlo);
                double stdDDR = Static.GetSTD(ddrCVM, meanDDR);
                double stdMonteCarlo = Static.GetSTD(ddrMT, meanMonteCarlo);
                meanModel.Add(meanDDR);
                meanMC.Add(meanMonteCarlo);
                stdModel.Add(stdDDR);
                stdMC.Add(stdMonteCarlo);
 
                List<double> monte_carlo_medians = Static.MedianSplit(monte_carlo, 5);
                List<double> ddr_medians = Static.MedianSplit(ddrMT, 5);
                mean_dist += Static.relativeDistance(monte_carlo_medians.ToArray(), ddr_medians.ToArray());

                double p = Static.GetProb(new List<double>(monte_carlo), new List<double>(ddrCVM));
                if (p > 0.05)
                {
                    ++passed_CVMs;
                }

                Console.Write("Test {0} \r", i + 1);
            }
            Console.WriteLine();
            mean_dist /= NTests;
            Console.WriteLine("Accuracy metric: mean median tree {0:0.0000}", mean_dist);
            Console.WriteLine("Passed Cramer von Mises DDR tests {0} from {1} tests", passed_CVMs, NTests);
            Console.WriteLine("Relative distance for means DDR - mean Monte Carlo {0:0.0000}", Static.relativeDistance(meanMC.ToArray(), meanModel.ToArray()));
            Console.WriteLine("Relative distance for STD   DDR - STD  Monte Carlo {0:0.0000}", Static.relativeDistance(stdMC.ToArray(), stdModel.ToArray()));
        }
    }
}
